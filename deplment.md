# 部署背景
部署这块儿我主要接触和使用的有两套方案，原生部署和容器式部署

# 原生部署

一般本地开发环境我使用的原生部署方式，首先安装一些必要的软件，数据库是Mysql和Redis、Python解释器，这里我们版本是3.9、依赖文件requments.txt文件，通过pip命令安装依赖，服务器使用Nginx反向代理后端Tornado服务，因为Tornado本身就是一款高性能web服务器，所以不需要第三方的参与，如果是django或者flask则需要wsgi或者gunicorn的参与。所有的服务我都会通过supervisor来进行统一管理，服务列表只需要维护一个supervisor配置即可，非常方便。

# Docker容器式部署话术

项目的容器式部署这块儿，测试环境和生产环境我们采用的是Docker容器式部署，当时我们主要考虑的是利用Docker部署简单方便，能够快速打包集成，另外非常重要的一点是可以很方便的进行多节点的分布式扩展，帮我们提高了不少的生产力，当然了，您也知道，容器式部署也有一些缺点，比如基于Docker容器的服务在性能上会损失一些，毕竟是在原生服务的基础上又套了一层，相当于封装了一层，这就有点像面向对象的概念，性能上有损耗，但是开发和部署效率上有提高，两难相权择其轻，另外，虽然单节点在性能上有损耗，解决方案就是利用Docker起多个节点，用nginx反向代理，做负载均衡，这里生产环境我们代理了两台服务器，这样就可以把性能缺陷这个劣势补救了回来，最后需要说明一点的是，nginx的负载均衡策略我们没有用默认的轮询，而是使用ip_hash的策略，因为我们的一些模块服务基于websocket协议，使用ip_hash可以保证长连接的有效性，部署业务就是这些了，我的介绍完了。


# 具体部署流程

一般先编写Docker的部署脚本文件Dockerfile：

- 首先挑选一下容器的基础镜像，这个镜像通常意义上就是我们用来部署的系统，当时我们有两个选择，一个ubuntu，另外一个是alpine，考虑alpine主要是看中了它的体积非常小，只有10m左右，但是经过测试，发现alpine不支持whl安装包的编译，也就是说如果系统升级做扩展的话，alpine无法进行系统编译操作，所以我们退而求其次选择了ubuntu，虽然它的体积大概100m左右，但是兼容性非常好。

- 随后把项目文件通过COPY命令拷贝到容器中，这里包括requests.txt，依赖文件，随后通过pip命令进行安装

- 依赖里面运行项目的服务我们选择了gunicorn，因为它是基于协程的，效率要比uwsgi高，流程上也比uwsgi方便

- 这块儿还有一个小坑，就是一般设置项目ip的时候我们都会直接写127.0.0.1，但是在Docker里一定得配置成0.0.0.0，否则外部系统是无法访问docker内容容器的

- 还有一点就是要设置容器内默认编码是utf-8，否则中文会乱码
- 最后配置完Dockerfile之后，执行 docker bulild就可以打包镜像了，非常方便。

# 参考攻略，必须实际动手操作一遍，不操作再怎么背也背不下来：

https://v3u.cn/a_id_179

alpine和ubuntu的区别：https://v3u.cn/a_id_173

